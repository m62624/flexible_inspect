variables:
  # ставим глобальную переменную image
  IMAGE: registry.gitlab.com/yourbandy-group/backend/pystval:latest

# ступени работы
stages:
  - BUILD
  - LINTER
  - TEST
  - DEPLOY

# Базовая сборка
Build Image (dependencies):
  stage: BUILD
  image: docker:stable
  services:
    - docker:dind
  tags:
    - production_runner
  before_script:
    # вводим данные для входа аккаунта
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    # получаем образ, если он существует, либо собираем по новой
    - docker pull $IMAGE || true
    # если есть прошлый образ, используем кэш (самое главное для скорости)
    - docker build --cache-from $IMAGE --build-arg BUILDKIT_INLINE_CACHE=1 -t $IMAGE .
    - ls -a
    # заливаем образ в `Gitlab Contrainer Registry` для повторного использования
    - docker push $IMAGE

# Проверяем сематнику & правописани
Linter check (clippy):
  stage: LINTER
  image: $IMAGE
  tags:
    - production_runner
  script:
    - cargo clippy -- -D warnings

# Запускаем все тесты + их покрытие

Coverage test:
  stage: TEST
  image: docker:stable
  services:
    - docker:dind
  tags:
    - production_runner
  before_script:
    # вводим данные для входа аккаунта
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    # получаем образ, если он существует, либо собираем по новой
    - docker pull local_check || true
    - docker run --security-opt seccomp=unconfined -v /var/run/docker.sock:/var/run/docker.sock $IMAGE cargo tarpaulin --engine llvm --out xml --output-dir ./coverage/
  coverage: /^\d+.\d+% coverage/
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: ./coverage/cobertura.xml

# Собираем пакеты для разных платформ
Packages:
  stage: DEPLOY
  image: $IMAGE
  tags:
    - production_runner
    # before_script:
    # вводим данные для входа аккаунта
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    # получаем образ, если он существует, либо собираем по новой
    - docker pull $IMAGE || true
    # build packages
    - make all
  rules:
    # если ветка main и это push или merge_request_event
    # то выполняем этот job, иначе пропускаем
    - if: '$CI_COMMIT_REF_NAME == "main" && ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "merge_request_event")'
  artifacts:
    paths:
      - ARTIFACTS_LINUX/
      - ARTIFACTS_MACOS/
      - ARTIFACTS_WINDOWS/

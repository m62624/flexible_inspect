variables:
  # ставим глобальную переменную image
  IMAGE: registry.gitlab.com/yourbandy-group/backend/pystval:latest

# ступени работы
stages:
  - BUILD
  - LINTER
  - TEST

# Базовая сборка
Build Image (dependencies):
  stage: BUILD
  image: docker:stable
  services:
    - docker:dind
  tags:
    - production_runner
  before_script:
    # вводим данные для входа аккаунта
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    # получаем образ, если он существует, либо собираем по новой
    - docker pull $IMAGE || true
    # если есть прошлый образ, используем кэш (самое главное для скорости)
    - docker build --cache-from $IMAGE --build-arg BUILDKIT_INLINE_CACHE=1 -t $IMAGE .
    - ls -a
    # заливаем образ в `Gitlab Contrainer Registry` для повторного использования
    - docker push $IMAGE

# Проверяем сематнику & правописани
Linter check (clippy):
  stage: LINTER
  image: $IMAGE
  tags:
    - production_runner
  script:
    - cargo clippy -- -D warnings

# Запускаем все тесты + их покрытие
Coverage test:
  stage: TEST
  image: docker:stable
  services:
    - docker:dind
  tags:
    - production_runner
  before_script:
    # вводим данные для входа аккаунта
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    # получаем образ, если он существует, либо собираем по новой
    - docker pull $IMAGE || true
    # запускаем контейнер с примонтированным разделом,
    # где находится исходный код
    # -v $CI_PROJECT_DIR:/app
    - docker run --security-opt seccomp=unconfined $IMAGE cargo tarpaulin --engine llvm --out xml --output-dir coverage/
  coverage: /^\d+.\d+% coverage/
  artifacts:
    name: ${CI_JOB_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}
    # сохраняем результат покрытия
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/*.xml
